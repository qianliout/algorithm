package main

import (
	"fmt"
)

func main() {
	fmt.Println(minMalwareSpread([][]int{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, []int{0, 1}))
	fmt.Println(minMalwareSpread([][]int{{1, 1, 0}, {1, 1, 1}, {0, 1, 1}}, []int{0, 1}))
	fmt.Println(minMalwareSpread([][]int{{1, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 1, 1}, {0, 0, 1, 1}}, []int{0, 1}))
	fmt.Println(minMalwareSpread([][]int{{1, 0, 0, 0, 0, 1, 0}, {0, 1, 1, 0, 0, 0, 0}, {0, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0}, {1, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 0, 1}}, []int{4}))
}

// 参考官方题解
func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	initSet := make([]int, n)
	for _, ch := range initial {
		initSet[ch] = 1
	}
	var dfs func(infSet []int, v int)
	dfs = func(infSet []int, v int) {
		for u := 0; u < n; u++ {
			if graph[v][u] == 0 {
				continue
			}
			if initSet[u] == 1 {
				continue
			}
			if infSet[u] == 1 {
				continue
			}
			infSet[u] = 1
			dfs(infSet, u)
		}
	}
	infBy := make([][]int, n)
	for _, v := range initial {
		infSet := make([]int, n)
		dfs(infSet, v)
		for k, cn := range infSet {
			if cn == 1 {
				infBy[k] = append(infBy[k], v)
			}
		}
	}
	count := make([]int, n)
	for _, ch := range infBy {
		if len(ch) == 1 {
			count[ch[0]]++
		}
	}
	ans := initial[0]

	for _, ch := range initial {
		if count[ans] < count[ch] || (count[ans] == count[ch] && ans > ch) {
			ans = ch
		}
	}
	return ans
}
