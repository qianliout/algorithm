package main

import (
	"fmt"
)

func main() {
	fmt.Println(minMalwareSpread([][]int{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, []int{0, 1}))
	fmt.Println(minMalwareSpread([][]int{{1, 1, 0}, {1, 1, 1}, {0, 1, 1}}, []int{0, 1}))
	fmt.Println(minMalwareSpread([][]int{{1, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 1, 1}, {0, 0, 1, 1}}, []int{0, 1}))
	fmt.Println(minMalwareSpread([][]int{{1, 0, 0, 0, 0, 1, 0}, {0, 1, 1, 0, 0, 0, 0}, {0, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0}, {1, 0, 0, 0, 0, 1, 0}, {0, 0, 0, 0, 0, 0, 1}}, []int{4}))
}

// 参考官方题解
func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	initSet := make([]int, n)
	for _, ch := range initial {
		initSet[ch] = 1
	}
	// 这录这些开始没有感染的节点，能被哪些初始节点感染
	infectedBY := make([][]int, n)
	for _, v := range initial {
		infectedSet := make([]int, n)
		dfs(graph, initSet, infectedSet, v)
		for u, cnt := range infectedSet {
			if cnt == 1 {
				infectedBY[u] = append(infectedBY[u], v)
			}
		}
	}
	ans := initial[0]
	count := make([]int, n)
	for _, v := range infectedBY {
		// 只能被一个节点感染
		if len(v) == 1 {
			count[v[0]]++
		}
	}

	for _, v := range initial {
		if count[v] > count[ans] || (count[v] == count[ans] && v < ans) {
			ans = v
		}
	}

	return ans
}

// 一个在 initial中的节点 v，能感染那些节点，记到 infectedSet中去
func dfs(g [][]int, initSet []int, infectedSet []int, v int) {
	n := len(g)
	for u := 0; u < n; u++ {
		if g[v][u] == 0 {
			continue
		}
		if initSet[u] == 1 {
			continue
		}
		// 说明之前已经被其他节点感染过，只记录初始节点
		// 也正是因为这一步，所以不需要记录那些被返问过,不会进入死循环
		if infectedSet[u] == 1 {
			continue
		}
		infectedSet[u] = 1
		dfs(g, initSet, infectedSet, u)
	}
}
