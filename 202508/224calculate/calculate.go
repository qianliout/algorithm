package main

import "fmt"

func main() {
	// 测试用例
	testCases := []string{
		"1 + 1",               // 简单加法
		" 2-1 + 2 ",           // 减法和加法
		"(1+(4+5+2)-3)+(6+8)", // 复杂括号表达式
		"2-(1+2)",             // 括号前有减号
	}

	for _, test := range testCases {
		result := calculate(test)
		fmt.Printf("表达式: %s = %d\n", test, result)
	}
}

// calculate 函数实现基本计算器，支持加减法和括号
// 算法思路：使用栈来处理括号，实时计算当前层级的结果
func calculate(s string) int {
	// 技巧1：在字符串末尾添加'+'，确保最后一个数字被处理
	// 这样避免了在循环结束后还要单独处理最后一个数字的情况
	s = s + "+"

	// op: 当前数字前的操作符，1表示+，-1表示-
	// 为什么用1和-1？这样可以直接用乘法来应用操作符：ans += op * num
	// num: 当前正在构建的数字（处理多位数字时需要逐位累积）
	op, num := 1, 0

	// 栈的作用：保存括号外的状态，实现嵌套括号的处理
	// nums: 栈，存储遇到'('时的当前计算结果（括号外已计算的部分）
	// ops: 栈，存储遇到'('时的操作符（括号前的操作符，决定括号结果如何与外层结合）
	nums := make([]int, 0)
	ops := make([]int, 0)

	// ans: 当前层级的计算结果
	// 注意：这是"当前层级"的结果，遇到括号时会重置为0开始新的计算
	ans := 0

	// 逐字符处理表达式
	for i := 0; i < len(s); i++ {
		c := s[i]
		switch c {
		case ' ':
			// 跳过空格
			continue

		case '+':
			// 遇到+号：先将当前数字加到结果中，然后设置下一个操作符为+
			ans += op * num
			op, num = 1, 0 // 重置操作符为+1，数字为0

		case '-':
			// 遇到-号：先将当前数字加到结果中，然后设置下一个操作符为-
			ans += op * num
			op, num = -1, 0 // 重置操作符为-1，数字为0

		case '(':
			// 遇到左括号：
			// 1. 先处理括号前的数字
			ans += op * num
			// 2. 将当前结果和操作符压入栈中（保存当前状态）
			nums = append(nums, ans)
			ops = append(ops, op)
			// 3. 重置所有变量，开始计算括号内的表达式
			op, num, ans = 1, 0, 0

		case ')':
			// 遇到右括号：
			// 1. 先处理括号内最后一个数字
			ans += op * num
			// 2. 将括号内的结果乘以括号前的操作符
			ans *= ops[len(ops)-1]
			// 3. 加上括号前的累计结果
			ans += nums[len(nums)-1]
			// 4. 弹出栈顶元素（恢复到括号前的状态）
			ops = ops[:len(ops)-1]
			nums = nums[:len(nums)-1]
			// 5. 重置操作符和数字
			op, num = 1, 0

		default:
			// 遇到数字字符：构建多位数字
			// 例如：遇到'1','2','3'依次构建出123
			num = num*10 + int(c) - int('0')
		}
	}

	// 处理最后一个数字（因为最后可能没有操作符）
	return ans // 上面把s做了处理之后，就可以保证会计算完
	// return ans + op*num
}

/*
算法执行示例：计算 "2-(1+2)"

初始状态：op=1, num=0, ans=0, nums=[], ops=[]

1. 遇到 '2'：num = 0*10 + 2 = 2
   状态：op=1, num=2, ans=0, nums=[], ops=[]

2. 遇到 '-'：ans += op * num = 0 + 1*2 = 2, op=-1, num=0
   状态：op=-1, num=0, ans=2, nums=[], ops=[]

3. 遇到 '('：
   - ans += op * num = 2 + (-1)*0 = 2
   - 保存状态：nums=[2], ops=[-1]
   - 重置：op=1, num=0, ans=0
   状态：op=1, num=0, ans=0, nums=[2], ops=[-1]

4. 遇到 '1'：num = 0*10 + 1 = 1
   状态：op=1, num=1, ans=0, nums=[2], ops=[-1]

5. 遇到 '+'：ans += op * num = 0 + 1*1 = 1, op=1, num=0
   状态：op=1, num=0, ans=1, nums=[2], ops=[-1]

6. 遇到 '2'：num = 0*10 + 2 = 2
   状态：op=1, num=2, ans=1, nums=[2], ops=[-1]

7. 遇到 ')'：
   - ans += op * num = 1 + 1*2 = 3 (括号内结果)
   - ans *= ops[top] = 3 * (-1) = -3 (应用括号前的操作符)
   - ans += nums[top] = -3 + 2 = -1 (加上括号前的累计结果)
   - 弹出栈：nums=[], ops=[]
   - 重置：op=1, num=0
   状态：op=1, num=0, ans=-1, nums=[], ops=[]

8. 字符串结束，返回：ans + op*num = -1 + 1*0 = -1

最终结果：-1 (正确，因为 2-(1+2) = 2-3 = -1)

关键理解点：
1. 栈用于保存括号外的状态
2. 每遇到'('就开始新的计算层级
3. 每遇到')'就完成当前层级并与上一层级合并
4. op变量记录当前数字前的操作符，这样可以正确处理负数
*/
