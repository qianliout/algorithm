package main

func main() {

}

func largestPathValue(colors string, edges [][]int) int {
	/*
	 * 解题思路：拓扑排序 + 动态规划
	 *
	 * 核心思想：
	 * 1. 这是一个有向图中求最长路径的问题（路径的"长度"定义为某种颜色出现的最多次数）
	 * 2. 首先用拓扑排序检测环，如果有环则无法求解
	 * 3. 用动态规划计算每个节点为终点的路径中，每种颜色的最大出现次数
	 * 4. dp[i][j] 表示：以节点i为终点的所有路径中，颜色j的最大出现次数
	 */

	n := len(colors)

	// 第一步：初始化DP数组
	// dp[i][j] = 以节点i为终点的路径中，颜色j的最大出现次数
	dp := make([][]int, n)
	for i := range dp {
		dp[i] = make([]int, 26) // 26个小写字母
	}

	// 第二步：构建图的邻接表和入度数组
	in := make([]int, n)    // in[i] = 节点i的入度
	out := make([][]int, n) // out[i] = 从节点i出发的所有邻接节点

	for _, ch := range edges {
		x, y := ch[0], ch[1]
		out[x] = append(out[x], y) // x -> y
		in[y]++                    // y的入度+1
	}

	// 第三步：拓扑排序初始化
	q := make([]int, 0) // 拓扑排序的队列

	// 找到所有入度为0的节点作为起始点
	for i := range in {
		if in[i] == 0 {
			q = append(q, i)
		}
	}

	// 第四步：拓扑排序 + 动态规划
	find := 0 // 记录处理过的节点数量，用于检测环

	for len(q) > 0 {
		find++    // 处理节点计数+1
		x := q[0] // 取出队首节点
		q = q[1:] // 出队

		/*
		 * 关键步骤1：更新当前节点的颜色计数
		 * 因为当前节点x被处理，说明所有到达x的路径都已经计算完毕
		 * 现在需要在x节点的颜色计数上+1（因为路径经过了x节点）
		 */
		c := cIdx(colors[x])
		dp[x][c]++

		/*
		 * 关键步骤2：更新所有后继节点的DP值
		 * 对于每个从x出发的边 x->y，需要用x的DP值来更新y的DP值
		 */
		for _, y := range out[x] {
			/*
			 * 重要说明：这里不需要visited检查！
			 *
			 * 原因：
			 * 1. 拓扑排序保证了每个节点只会在入度为0时被处理一次
			 * 2. 但是，一个节点可能被多个前驱节点更新多次，这是正确的！
			 * 3. 我们需要所有前驱的信息来计算最优的dp值
			 *
			 * 例如：如果节点y有两个前驱x1和x2，我们需要：
			 * - 从x1更新：dp[y][i] = max(dp[y][i], dp[x1][i])
			 * - 从x2更新：dp[y][i] = max(dp[y][i], dp[x2][i])
			 * 这样才能得到到达y的最优路径信息
			 */

			/*
			 * 状态转移方程：dp[y][i] = max(dp[y][i], dp[x][i])
			 *
			 * 思考过程：
			 * - dp[x][i] 表示以x为终点的路径中颜色i的最大出现次数
			 * - 现在有边 x->y，所以可以通过x到达y
			 * - 因此，以y为终点的路径中颜色i的出现次数至少可以达到dp[x][i]
			 * - 取最大值是因为可能有多条路径到达y，我们要保留最优的结果
			 */
			for i := 0; i < 26; i++ {
				dp[y][i] = max(dp[y][i], dp[x][i])
			}

			/*
			 * 拓扑排序的标准操作：
			 * 1. 减少后继节点的入度
			 * 2. 如果入度变为0，说明该节点的所有前驱都已处理完，可以加入队列
			 */
			in[y]--
			if in[y] == 0 {
				q = append(q, y)
			}
		}
	}

	// 第五步：环检测
	// 如果处理的节点数不等于总节点数，说明存在环
	if find != n {
		return -1
	}

	// 第六步：找到所有DP值中的最大值
	ans := 0
	for i := range dp {
		for _, ch := range dp[i] {
			ans = max(ans, ch)
		}
	}

	return ans
}

func cIdx(c byte) int {
	return int(c) - int('a')
}

/*
算法执行示例：
输入：colors = "abaca", edges = [[0,1],[0,2],[2,3],[3,4]]

图结构：
    0(a)
   /    \
  1(b)   2(a)
         |
         3(c)
         |
         4(a)

执行过程：

1. 初始化：
   - dp = [[0,0,0,...], [0,0,0,...], [0,0,0,...], [0,0,0,...], [0,0,0,...]]
   - in = [0, 1, 1, 1, 1]  // 各节点入度
   - queue = [0]  // 只有节点0入度为0

2. 处理节点0：
   - dp[0][0]++ → dp[0] = [1,0,0,...]  // 节点0是'a'，所以a的计数+1
   - 更新后继节点1和2：
     - dp[1] = max([0,0,0,...], [1,0,0,...]) = [1,0,0,...]
     - dp[2] = max([0,0,0,...], [1,0,0,...]) = [1,0,0,...]
   - 减少入度：in[1]--, in[2]-- → in = [0,0,0,1,1]
   - 节点1和2入度变为0，加入队列：queue = [1,2]

3. 处理节点1：
   - dp[1][1]++ → dp[1] = [1,1,0,...]  // 节点1是'b'，所以b的计数+1
   - 节点1没有后继，继续

4. 处理节点2：
   - dp[2][0]++ → dp[2] = [2,0,0,...]  // 节点2是'a'，所以a的计数+1
   - 更新后继节点3：
     - dp[3] = max([0,0,0,...], [2,0,0,...]) = [2,0,0,...]
   - 减少入度：in[3]-- → in = [0,0,0,0,1]
   - 节点3入度变为0，加入队列：queue = [3]

5. 处理节点3：
   - dp[3][2]++ → dp[3] = [2,0,1,...]  // 节点3是'c'，所以c的计数+1
   - 更新后继节点4：
     - dp[4] = max([0,0,0,...], [2,0,1,...]) = [2,0,1,...]
   - 减少入度：in[4]-- → in = [0,0,0,0,0]
   - 节点4入度变为0，加入队列：queue = [4]

6. 处理节点4：
   - dp[4][0]++ → dp[4] = [3,0,1,...]  // 节点4是'a'，所以a的计数+1
   - 节点4没有后继，结束

7. 最终结果：
   - dp[0] = [1,0,0,...]  // 路径到节点0：'a'出现1次
   - dp[1] = [1,1,0,...]  // 路径到节点1：'a'出现1次，'b'出现1次
   - dp[2] = [2,0,0,...]  // 路径到节点2：'a'出现2次
   - dp[3] = [2,0,1,...]  // 路径到节点3：'a'出现2次，'c'出现1次
   - dp[4] = [3,0,1,...]  // 路径到节点4：'a'出现3次，'c'出现1次

   最大值 = 3（路径 0→2→3→4 中'a'出现3次）

关键理解：
- dp[i][j] 始终表示"以节点i为终点的最优路径中，颜色j的最大出现次数"
- 拓扑排序保证了处理顺序的正确性：先处理前驱，再处理后继
- 状态转移时，我们将前驱节点的最优结果传递给后继节点
*/
