package main

import (
	"slices"
)

func main() {

}

func minimumTime(n int, relations [][]int, time []int) int {
	/*
	 * 解题思路：拓扑排序 + 动态规划
	 *
	 * 核心思想：
	 * 1. 这是一个有向无环图(DAG)的最长路径问题
	 * 2. 每个课程都有学习时间，需要找到完成所有课程的最短总时间
	 * 3. 关键洞察：可以并行学习没有依赖关系的课程
	 * 4. dp[i] 表示完成课程i所需的最早时间点
	 */

	// 第一步：构建图和计算入度
	// g[i] 存储课程i的后续课程列表（邻接表表示法）
	g := make([][]int, n)
	// in[i] 存储课程i的入度（有多少门先修课程）
	in := make([]int, n)

	// 构建有向图：prevCourse -> nextCourse
	for _, ch := range relations {
		x, y := ch[0]-1, ch[1]-1 // 转换为0索引
		g[x] = append(g[x], y)   // x课程完成后可以学习y课程
		in[y]++                  // y课程的先修课程数量+1
	}

	// 第二步：找到所有没有先修课程的课程（入度为0）
	// 这些课程可以立即开始学习
	queue := make([]int, 0)
	for k, v := range in {
		if v == 0 {
			queue = append(queue, k) // 没有先修课程，可以立即开始
		}
	}

	// 第三步：动态规划 + 拓扑排序
	// dp[i] 表示完成课程i的最早时间点
	dp := make([]int, n)

	// 拓扑排序处理每个课程
	for len(queue) > 0 {
		// 取出一个可以开始学习的课程
		fir := queue[0]
		queue = queue[1:]

		/*
		 * 关键理解：dp[fir] 在这里的含义
		 * - 进入这里时，dp[fir] 已经是所有先修课程完成的最晚时间
		 * - 加上 time[fir] 就是完成当前课程fir的时间点
		 * - 这个时间点就是fir课程"毕业"的时间
		 */
		dp[fir] = dp[fir] + time[fir]

		// 第四步：更新后续课程的开始时间
		for _, nex := range g[fir] {
			/*
			 * 核心逻辑：课程nex要开始学习，必须等待所有先修课程完成
			 * dp[fir] 是刚完成的先修课程fir的完成时间
			 * dp[nex] 是之前计算的其他先修课程的最晚完成时间
			 * 取最大值确保nex在所有先修课程都完成后才开始
			 */
			dp[nex] = max(dp[fir], dp[nex])

			// 减少nex的入度，表示又完成了一门先修课程
			in[nex]--

			// 如果nex的所有先修课程都完成了，可以开始学习nex
			if in[nex] == 0 {
				queue = append(queue, nex)
			}
		}
	}

	/*
	 * 第五步：返回结果
	 * 所有课程中完成时间最晚的那个，就是完成所有课程需要的总时间
	 * 因为可以并行学习，所以不是所有时间的总和，而是最长路径的时间
	 */
	return slices.Max(dp)
}

/*
给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。
请你根据以下规则算出完成所有课程所需要的 最少 月份数：
如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。
你可以 同时 上 任意门课程 。
请你返回完成所有课程所需要的 最少 月份数。
注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）

算法执行示例：
假设有4门课程，relations = [[1,3],[2,3],[3,4]], time = [3,2,5,1]

初始状态：
- 课程1: 无先修课，time=3
- 课程2: 无先修课，time=2
- 课程3: 先修课1,2，time=5
- 课程4: 先修课3，time=1

执行过程：
1. 初始队列：[0,1] (课程1,2无先修课)
2. 处理课程1：dp[0] = 0 + 3 = 3，更新课程3：dp[2] = max(3, 0) = 3
3. 处理课程2：dp[1] = 0 + 2 = 2，更新课程3：dp[2] = max(2, 3) = 3
4. 课程3入队：dp[2] = 3 + 5 = 8，更新课程4：dp[3] = max(8, 0) = 8
5. 课程4入队：dp[3] = 8 + 1 = 9

最终结果：max(3, 2, 8, 9) = 9个月

关键理解：
- 课程1和2可以并行学习（0-3月学课程1，0-2月学课程2）
- 课程3必须等到第3月才能开始（等课程1完成），第8月完成
- 课程4必须等到第8月才能开始，第9月完成
*/
