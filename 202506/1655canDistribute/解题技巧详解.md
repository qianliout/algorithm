# canDistribute 问题详解

## 问题描述
给你一个长度为 n 的整数数组 nums，这个数组中至多有 50 个不同的值。同时你有 m 个顾客的订单 quantity，判断是否能将 nums 中的整数分配给这些顾客，且满足：
1. 第 i 位顾客恰好有 quantity[i] 个整数
2. 第 i 位顾客拿到的整数都是相同的
3. 每位顾客都满足上述两个要求

## 核心思路

### 1. 问题转化
- 原问题：分配数字给顾客
- 转化为：每种数字选择满足哪些顾客的子集

### 2. 关键约束分析
- quantity 数组长度最多 10 → 可以用状态压缩
- nums 中最多 50 个不同值 → 可以枚举每种数字
- 每个顾客需要相同数字 → 一种数字只能分配给一个顾客

## 解题技巧

### 技巧1：状态压缩
```
用二进制表示顾客集合：
- 0: 没有顾客被满足
- 1: 第0个顾客被满足
- 3: 第0和第1个顾客被满足 (二进制11)
- 7: 前3个顾客都被满足 (二进制111)
```

### 技巧2：预处理子集和
```go
// 计算所有顾客子集的总需求量
for i, ch := range quantity {
    bit := 1 << i
    for j := 0; j < bit; j++ {
        sum[bit|j] = sum[j] + ch
    }
}
```

**原理解释：**
- `bit = 1 << i` 表示只包含第i个顾客的集合
- `j` 遍历所有不包含第i个顾客的集合
- `bit|j` 表示在集合j基础上加入第i个顾客
- 这样可以O(2^m)时间计算所有子集的和

### 技巧3：子集枚举
```go
// 枚举mask的所有子集
for sub := mask; sub > 0; sub = (sub - 1) & mask {
    // sub 是 mask 的子集
}
```

**位运算技巧：**
- `sub - 1`：将sub的最低位1变为0，其右边的0都变为1
- `(sub - 1) & mask`：确保结果仍是mask的子集
- 这个技巧可以按字典序遍历所有子集

### 技巧4：动态规划状态设计
```
dp[i][mask] = 前i种数字能否满足mask表示的顾客集合
```

**状态转移：**
1. 不使用第i种数字：`dp[i+1][mask] = dp[i][mask]`
2. 使用第i种数字满足子集sub：
   - 条件1：`sum[sub] <= count[i]` (数量足够)
   - 条件2：`dp[i][mask^sub] = true` (剩余顾客可被前i种数字满足)
   - 转移：`dp[i+1][mask] = true`

## 算法步骤详解

### 步骤1：预处理
```go
// 1. 计算所有顾客子集的总需求
// 2. 统计每种数字的出现次数
```

### 步骤2：初始化DP
```go
// dp[i][0] = true (不满足任何顾客总是可能的)
```

### 步骤3：状态转移
```go
for 每种数字 {
    for 每个状态mask {
        if dp[i][mask] {
            dp[i+1][mask] = true // 不使用当前数字
        } else {
            // 枚举mask的子集，尝试用当前数字满足
            for sub := mask; sub > 0; sub = (sub-1) & mask {
                if 当前数字数量 >= sub需求 && dp[i][mask^sub] {
                    dp[i+1][mask] = true
                    break
                }
            }
        }
    }
}
```

### 步骤4：返回结果
```go
return dp[n][2^m - 1] // 所有顾客都被满足
```

## 复杂度分析
- 时间复杂度：O(n × 3^m)
  - n种不同数字
  - 每种数字需要枚举2^m个状态
  - 每个状态需要枚举其所有子集，总共3^m次操作
- 空间复杂度：O(n × 2^m)

## 关键优化点
1. **提前剪枝**：如果dp[i][mask]已经为true，直接继承
2. **子集枚举优化**：使用位运算快速枚举子集
3. **预处理优化**：提前计算所有子集的需求总和

## 易错点
1. 子集枚举的边界条件（sub > 0）
2. 状态转移中的异或操作（mask^sub）
3. 初始状态的设置（dp[i][0] = true）
4. 最终答案的状态（2^m - 1）
